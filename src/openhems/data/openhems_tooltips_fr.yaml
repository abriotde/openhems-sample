# Generated by Deepseek "Could you, please, translate YAML values from english to french?"
api:
  url: "URL HTTP pour l'API Home-Assistant. Généralement : http://127.0.0.1:8123/api"
  long_lived_token: "Jeton d'accès long durée Home-Assistant (à générer dans l'interface : Profil utilisateur → Sécurité → Créer un jeton)."
  ssl_certificate: "Chemin du certificat SSL. Non géré correctement pour le moment."
localization:
  latitude: "Latitude du domicile (utile pour les panneaux solaires et les prévisions météo)"
  longitude: "Longitude du domicile (utile pour les panneaux solaires et les prévisions météo)"
  altitude: "Altitude du domicile (utile pour les panneaux solaires)"
  timeZone: "Fuseau horaire : Identifiant TZ (liste : https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List)"
  language: "Code langue ('fr' pour français, 'en' pour anglais)"
server:
  htmlRoot: "Répertoire racine du serveur web."
  inDocker: "True si OpenHEMS s'exécute dans Docker."
  port: "Port d'écoute du serveur web."
  logformat: "Format des logs (documentation : https://docs.python.org/3/library/logging.html#logrecord-attributes)"
  logfile: "Chemin du fichier de logs"
  loglevel: "Niveau de logs (critical, error, warning, info, debug)"
  loopDelay: "Intervalle entre deux cycles OpenHEMS. Un délai court améliore la réactivité, mais augmente la charge CPU."
  network: "Mode de connexion au réseau domestique (options : homeassistant, fake)"
  strategies: "Algorithmes de gestion de l'énergie (offpeak, emhass, solarnosell, etc.)."
network:
  nodes: "Configuration des nœuds domestiques"
default:
  strategy:
    emhass:
      freq: "Fréquence d'analyse par l'IA (doit être supérieure à server.loopDelay)"
      days_to_retrieve: "Historique en jours analysé pour comprendre les habitudes"
      method_ts_round: ""
      delta_forecast: ""
      weather_forecast_method: ""
      set_total_pv_sell: False
      lp_solver: default
      lp_solver_path: empty
      set_nocharge_from_grid: False
      set_nodischarge_to_grid: True
      set_battery_dynamic: False
      battery_dynamic_max: 0.9
      battery_dynamic_min: -0.9
    offpeak:
      improvedSecurity: true
    switchoff:
      reverse: False
      offhours: []
      offconditions: False
    annealing:
      freq: "Fréquence d'étude d'optimisation (doit être supérieure à server.loopDelay)"
      max_iteration_number: "Nombre maximal d'itérations par cycle."
      initial_temp: "Température initiale de l'algorithme."
      cooling_factor: "Facteur de refroidissement."
      min_temp: "Température minimale."
      max_no_improve: "Nombre maximal d'itérations sans amélioration."
    nosell:
      ratio: "Ratio abstrait (-1 = ne jamais vendre, 1 = ne jamais acheter)."
      margin: "Marge de sécurité en kWh pour éviter les bascules intempestives."
      cycleDuration: "Nombre de cycles requis pour activer/désactiver un appareil (évite l'effet yo-yo)."
      refCoefficient: "Seuil abstrait pour activer les appareils indépendamment du cycleDuration."
    nobuy:
      ratio: "Similaire à la stratégie 'nosell'"
      margin: "Similaire à la stratégie 'nosell'"
    ratiosellbuy:
      ratio: "Similaire à la stratégie 'nosell'"
      margin: "Similaire à la stratégie 'nosell'"
  node:
    publicpowergrid:
      currentPower: null
      maxPower: "Puissance maximale fournie par le réseau (en kWh) avant blackout."
      minPower: "Puissance minimale fournie par le réseau (0 si vente impossible)."
      marginPower: "Marge de sécurité en kWh."
      contract:
        rtetempo:
          color: "ID du capteur indiquant la couleur Tempo (sinon API)."
          nextcolor: ""
          offpeakhoursranges: "Plages horaires d'heures creuses."
          peakprice:
            bleu: ""
            blanc: ""
            rouge: ""
          offpeakprice:
            bleu: ""
            blanc: ""
            rouge: ""
        rteheurescreuses:
          offpeakhoursranges: ""
          peakprice: ""
          offpeakprice: ""
        rtetarifbleu:
          price: ""
        generic:
          offpeakhoursranges: ""
          defaultPrice: ""
          outRangePrice: ""
          sellprice: ""
    solarpanel:
      currentPower: "ID HA de la puissance actuelle (en kW) des panneaux."
      maxPower: "Puissance maximale théorique des panneaux (kW)."
      moduleModel: ""
      inverterModel: ""
      tilt: "Angle d'inclinaison (degrés)."
      azimuth: "Orientation depuis le nord (degrés)."
      modulesPerString: ""
      stringsPerInverter: ""
      marginPower: "Marge de sécurité en kWh."
    battery:
      currentPower: "ID HA de la puissance d'entrée/sortie (en kW)."
      maxPowerIn: "Puissance maximale de charge (kW)."
      maxPowerOut: "Puissance maximale de décharge (kW)."
      efficiencyIn: "Rendement de charge (%)"
      efficiencyOut: "Rendement de décharge (%)"
      capacity: "Capacité totale (kWh)"
      currentLevel: "ID HA du niveau de charge (%)"
      lowLevel: "Niveau minimal conseillé (%)"
      highLevel: "Niveau maximal conseillé (%)"
      targetLevel: "Niveau de charge cible en fin de journée (%)."
    switch:
      currentPower: "ID HA de la puissance consommée (kW)"
      maxPower: "Puissance maximale attendue (kW)"
      isOn: "ID HA de l'état (on/off)"
      strategy: "ID de la stratégie associée."
      priority: "Priorité (0-100) : plus élevée = plus critique."
      sensor: "Si présent, l'identifiant HA d'un capteur pour le retour d'information : activation/désactivation automatique."
      target: "Cible du capteur, le cas échéant. Possibilité de configurer la valeur de la variable pendant la journée. Configuré comme 'offHours'."
      constraint:
        minPower: "Si défini : si la consommation de l'appareil, passe dessous cette valeur, l'appareil est éteind."
        maxPower: "Si défini : si la consommation de l'appareil dépasse cette valeur, l'appareil s'éteint."
        minDurationOn: "Durée, en secondes : ne pas éteindre l'appareil avant qu'il ait été allumé pendant cette durée."
        minDurationOff: "Durée, en secondes : ne pas allumer l'appareil avant qu'il ait été éteint pendant cette durée."
        maxDurationOn: "Durée, en secondes : éteindre l'appareil s'il a été allumé pendant cette durée."
        maxDurationOff: "Durée, en secondes : allumer l'appareil s'il a été éteint pendant cette durée."

